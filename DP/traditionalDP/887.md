
## 887 Super Egg Drop

#### Description

[link](https://leetcode.com/problems/super-egg-drop/description/)

---

#### Solution DP TLE

dp[k][n] : steps to use k eggs to detect n floors

Recrusive : dp[k][n] = min(1 + max(dp[k - 1][i - 1], dp[k][n - i])) i = 1...n. (image one egg to detect i floor)

Initial :

- dp[0][i]=0, i=1...N # no egg, no floor can check
- dp[1][i]=i, i=1...N # one egg, check floor from i to 1
- dp[j][1]=1, j=1...K # one floor, only check once

---

#### Code

> Complexity T : O(KN^2) M : O(KN)

```python
class Solution:
    def superEggDrop(self, K, N):
        """
        :type K: int
        :type N: int
        :rtype: int
        """
        # dp[k][n] : steps to use k eggs to detect n floors
        # Recrusive : dp[k][n] = min(1 + max(dp[k - 1][i - 1], dp[k][n - i])) i = 1...n. (image one egg to detect i floor)
        # Initial :
        #   dp[0][i]=0, i=1...N # no egg, no floor can check
        #   dp[1][i]=i, i=1...N # one egg, check floor from i to 1
        #   dp[j][1]=1, j=1...K # one floor, only check once
        
        dp = [[0] * (N + 1) for _ in range(K + 1)]
        
        for i in range(1, N + 1):
            dp[0][i] = 0
            dp[1][i] = i
        for j in range(1, K + 1):
            dp[j][1] = 1
        
        for k in range(2, K + 1):
            for n in range(2, N + 1):
                dp[k][n] = float("inf")
                for i in range(1, n + 1):
                    dp[k][n] = min(dp[k][n], 1 + max(dp[k - 1][i - 1], dp[k][n - i]))
        
        return dp[K][N]
```
